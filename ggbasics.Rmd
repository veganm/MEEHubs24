---
title: "gg_basics"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

# Background
In this session we will:
* Learn the basic parts and syntax of a ggplot call
* Understand how ggplot expects input data to be organized
* Practice manipulating data structures to make plotting easier
* Explore some of the basic design options that ggplot makes available to you

Before we begin, make sure that you:
* Have R and Rstudio installed (this code was written in R4.3.1 "Beagle Scouts")
* Have a working directory set up for R
* Understand the basics of how R creates and handles objects


# Getting Started
First, let's install and load in the packages we will need to use. We will be working with *ggplot()* (package *ggplot2*) for plot creation, which along with the data manipulation tools that we will need today, is part of the R Tidyverse. We also want some extra plot manipulation ability from a package called *cowplot* and some extra color options from *RColorBrewer*. And, in case you didn't attend the Absolute Basics workshop, you will also need to get the Pokemon data set. All of these are available on CRAN (the official R project repository) and can be installed directly using *install.packages()* and *library()* from base R.

However, there's a faster way to get all this done. The package *pacman* (PACkage MANagement tool) conveniently wraps library and package related functions and names them in an intuitive and consistent fashion to speed up workflow. Let's see it in action. First, we'll install *pacman* the old-fashoned way:
```{r}
install.packages("pacman")
```

Now that pacman is installed, we can use its *p_load()* function to speed up library handling. This function takes a list of CRAN packages, checks to see whether you already have them installed, installs anything that's missing, then loads everything in the list into your workspace. All with one call!
```{r}
pacman::p_load(tidyverse, RColorBrewer, pokemon, colorspace, dichromat, remotes)
```

(By way of explanation here: The syntax *package::function()* tells R to execute the named function as coded in the specified package. This is useful when there are functions with the same name in different packages, to make sure you are calling the right one when you need it, and when you only need the one function and don't want to load an entire package.)

# Viewing The Data
Let's see what we're dealing with. Base R had a few options for looking at a data set directly, and those still work. For example, *View()* can be used to pop up the data as a table in a new tab.  
```{r}
View(pokemon)
```

Likewise, we can choose to print a few rows and columns to the screen:
```{r}
print(pokemon, n=10, width=6)
```

However, Tidyverse has given us some new tools that are worth trying out. The *glimpse()* function provided via package *dplyr* will show a transposed version of the data (columns run down the page, data runs across) along with the dimensions of the data and will try to show you as much of the data as possible:
```{r}
glimpse(pokemon)
```
This view is nice because it lets you see all the data types along with a snapshot of the first few rows, to get an idea of what the data set contains.

The names of the data are the column headers:
```{r}
names(pokemon)
```


# Plotting With ggplot
*ggplot2* is the most-used package for producing data visualizations in R. It's tremendously powerful and flexible, with many, many ways to customize a plot. 

The basics of a *ggplot2* call are simple. You need to provide, at minimum:
* **Data** (the name of the data frame that contains the data for plotting)
* **Aesthetics** (aes; what is being mapped onto the x and y axes, as well as what information you want to use to determine the attributes such as color, shape, size, etc. of plot elements)
* **Geometry** (what kind of plot - scatter, line, bar, histogram...) 


## Syntax
Let's say that we want to begin with attack vs defense. These are both *quantitative* variables, so a scatterplot (where the x and y axis are both continuous numeric scales) is appropriate. In base R, the simplest way to make this plot is:
```{r}
plot(pokemon$attack, # x axis
     pokemon$defense, # then y axis
     type="p",       # "p" for points
     main="Pokemon Attack vs Defense"
     )
```

In *ggplot2*, we explicitly define the data, aesthetics (at a minimum the x and y), and geometry as:
```{r}
ggplot(pokemon, aes(attack, defense)) +  # data + aesthetics (x,y) 
  geom_point() # creates a scatter plot
```

Inside the geometry, we can do things like change the color, shape, and size of all of the points. To see options for point shapes, check out
```{r}
?par
?points
```

and for colors:
```{r}
?colors # you want colors {grDevices}
colors(distinct = TRUE)
```

OK, now the plot. Try changing these options! 
```{r}
ggplot(pokemon, aes(attack, defense)) +  # data + aesthetics (x,y) 
  geom_point(shape="square", size=0.5, color="red") # creates a scatter plot
```

We can add informative aesthetics by using one or more of the *categorical variables* to divide the data into groups. For example, Pokemon type 1 is a factor with levels:
```{r}
unique(pokemon$type_1)
```

We can use this information to color each point according to the type of the Pokemon:
```{r}
ggplot(pokemon, aes(attack, defense, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point()
```

Since there are so many points, we can try making them a little bit transparent to see if that helps:
```{r}
ggplot(pokemon, aes(attack, defense, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point(alpha=0.5) #alpha is a number between 0 and 1 that specifies opacity - try changing this!
```

We can add more than one informational aesthetic at a time. For example:
```{r}
ggplot(pokemon,  # the data
       aes(attack, defense,  # x and y
           color=type_1, # color points by type
           shape=generation_id  # point shape indicates generation
           )) +   
  geom_point()
```

That didn't work! We tried to use a numeric variable (generation_id is a *double*, a non-integer numeric value) as a category! Also, as it turns out, not all of the entries have a generation assigned; we'll deal with that later.
```{r}
unique(pokemon$generation_id)
```

Fortunately, it's easy to convert a numeric variable to a categorical one - as long as the number of unique values is usably small.
```{r}
unique(as.factor(pokemon$generation_id))
```

If we tell *ggplot()* to use generation ID *as a factor* (as if each unique value is the label for a category), now our plot will work.
```{r}
ggplot(pokemon,  # the data
       aes(attack, defense,  # x and y
           color=type_1, # color points by type
           shape=as.factor(generation_id)  # point shape indicates generation
           )) +   
  geom_point(alpha=0.8) # remember that alpha in [0,1] controls point opacity
```

The plot now is so busy that R is warning us about our design! Don't worry, we'll simplify this plot so it's usable later. But first, a few more design elements.

## Themes
We don't have to stick with the basic design. In *ggplot*, you can specify *themes* that provide different defaults for plot structural elements like the plot background and axes. Let's try a few!
```{r}
# Un-comment one theme at a time by removing the hash tag at the start of the line.
# Remember that you can only have one theme at a time, 
# so be sure to put a hash tag in front of any themes you aren't using!
ggplot(pokemon, aes(attack, defense, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  theme_void()
#  theme_minimal()
#  theme_nothing()
#  theme_grey()
#  theme_dark()
#  theme_light()
#  theme_classic()
#  theme_bw()
```

For information on a given theme, consult its help file:
```{r}
?theme_classic
```


**EXERCISE: Now you try!** Use the empty code block below to make a new scatter plot of your own. Use a different set of x and y components - what other pair(s) of numeric data might be interesting? Try changing the shape, size, color, and/or transparency of the points, and try a few different themes. What options make the plot more or less legible?
```{r}

```


## Theme Elements and Plot Labels
We can control the size/position/color/etc of text, and change how different plot elements are labeled, with *theme()*. 
```{r}
?theme
```


Try changing some of these options!
```{r}
ggplot(pokemon, aes(attack, defense, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  theme_classic() + # the classics never get old
    theme(axis.text=element_text(size=14), 
        axis.title=element_text(size=14, face="bold", color="blue"), 
        plot.title=element_text(hjust=0.5, size=14),  # hjust to center the text
        legend.text=element_text(size=8),
        legend.title=element_text(size=12)) +
  labs(title="Attack vs defense", y="Defense", x="Attack", color="Type 1")
```

You can also remove text elements by making them blank:
```{r}
ggplot(pokemon, aes(attack, defense, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  theme_classic() + # the classics never get old
    theme(axis.text=element_text(size=14), 
        axis.title=element_text(size=14, face="bold"), 
        plot.title=element_text(hjust=0.5, size=14),  # hjust to center the text
        legend.text=element_text(size=8),
        legend.title=element_blank()   # removes the legend title
        ) +
  labs(title="Attack vs defense", y="Defense", x="Attack")
```

And remove elements entirely by setting *element.position = "none"*:
```{r}
ggplot(pokemon, aes(attack, defense, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  theme_classic() + # the classics never get old
    theme(axis.text=element_text(size=14), 
        axis.title=element_text(size=14, face="bold"), 
        plot.title=element_text(hjust=0.5, size=14),  # hjust to center the text
        legend.text=element_text(size=14),
        legend.position="none"             # no more legend!
        ) +
  labs(title="Attack vs defense", y="Defense", x="Attack")
```

**EXERCISE: Now you try!** Use the empty code block below to modify the themes and labels of your own plot. Play around with centering of different elements (using hjust and vjust), fonts, colors... 
```{r}

```


# ggplot vs geom Elements
One very important thing about ggplot is how aesthetics are inherited. So far, we have been specifying aesthetics in the call to *ggplot()*. When we do this, the aesthetics are *inherited* by all of the geometries - and we can specify more than one!

Let's say we want to add lines to the scatter plot, to show the relationship between the attack and defense variables. The geometry *geom_line()* will add a line plot, using lines to connect adjacent points:
```{r}
ggplot(pokemon, aes(attack, defense, color=as.factor(generation_id))) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  geom_line() +  # Produces a line connecting data points
  theme_classic() # the classics never get old
```

Technically that worked, but the plot is even more busy than before, and this doesn't do a very good job of showing the relationship between our x and y variables. There's a better choice for that job.
```{r}
?geom_smooth()
```

Let's see it in action:
```{r}
ggplot(pokemon, aes(attack, defense, color=as.factor(generation_id))) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  geom_smooth() +  # Produces a smoothed line showing data trends
  theme_classic() # the classics never get old
```
As you can see, the smoothed line is the same color as the points.

If we instead put the color aesthetic in the first geometry, this happens:
```{r}
ggplot(pokemon, aes(attack, defense)) +  # data + aesthetics (x, y, point color) 
  geom_point(aes(color=as.factor(generation_id))) +
  geom_smooth() +  # Produces a smoothed line showing data trends
  theme_classic() 
```

*geom_smooth* still inherits the aesthetics from the call to *ggplot* - it's just that we didn't supply a color aesthetic there! Now only the *geom_point()* layer can use the information about generation ID.
What if we put the color aesthetic into the *geom_smooth* function?
```{r}
ggplot(pokemon, aes(attack, defense)) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  geom_smooth(aes(color=as.factor(generation_id))) +  # Produces a smoothed line showing data trends
  theme_classic() 
```

Same thing. When we specify the color aesthetic in the "boss" call to *ggplot*, all of the geometries can use it (unless we tell them not to). If we specify an aesthetic in only one element, only that element gets to use it.

*ggplot* will let you **overwrite** aesthetics, which comes in handy if you do have more than one layer of elements in a plot. For example, if we want to force all of the smoothed lines to be the same color, we can easily do so by giving the *geom_smooth* a local value for color. This will replace the global color scheme based on generation, only within the smoothed-lines layer.
```{r}
ggplot(pokemon, aes(attack, defense, color=as.factor(generation_id))) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  geom_smooth(aes(group=1)) +  # Produces a smoothed line showing data trends
  theme_classic() # the classics never get old
```


**EXERCISE: Now you try!** Use the empty code block below to modify the aesthetic inheritances in your own plot. What difference does it make when you move a color/shape aesthetic from the main call into the geometry call? What difference does it make when you have more than one geometry? 
```{r}

```




# Fine-Tuning the Aesthetics: Color Scales, Palettes, and RColorBrewer
Let's see if there is any relationship between attack/defense components and speed.
```{r}
pAttackVsSpeed <- ggplot(pokemon, aes(attack, defense, color=speed)) +  # data + aesthetics (x, y, point color) 
  geom_point()
pAttackVsSpeed
```


Maybe, but it's hard to see like this. We don't have to use the default colors - in fact, we probably shouldn't.

Since we are trying to color the points according to a numeric (continuous) variable, we need a *continuous color scale*. We can do this with a custom *color gradient*:
```{r}
pAttackVsSpeed + scale_color_gradient(low="blue", high="darkorange")
```
We can also set up a three-color gradient:
```{r}
pAttackVsSpeed +
  scale_color_gradient2(low="blue", mid="violet", high="darkred")
```


By default, the  midpoint of the color scale is 0, but clearly that doesn't work here. Instead, we can set the midpoint (try a few different values!):
```{r}
pAttackVsSpeed +  
  scale_color_gradient2(low="blue", mid="violet", high="darkred", midpoint=85)
```

Or we can specify a pre-made continuous color scale (here, the Viridis continuous scale, which is perceptually uniform in both colour and black-and-white display, is an easy option to ensure good perceptive properties of your visulizations):
```{r}
pAttackVsSpeed + scale_color_viridis_c()
```
We can take a given gradient and run it backwards:
```{r}
pAttackVsSpeed + scale_color_viridis_c(direction=-1)
```
Viridis_c presents eight scales as options:
```{r}
pAttackVsSpeed +
  scale_color_viridis_c(option="turbo")
#  scale_color_viridis_c(option="mako")
#  scale_color_viridis_c(option="rocket")
#  scale_color_viridis_c(option="cividis")
#  scale_color_viridis_c(option="viridis")
#  scale_color_viridis_c(option="plasma")
#  scale_color_viridis_c(option="inferno")
#  scale_color_viridis_c(option="magma")
```




# Testing Color Palettes
As part of selecting or creating color palettes, it is important to make sure that your chosen color scheme will still work well when desaturated (black and white) and for viewers with different forms of color-blindness. Fortunately, there are ways of assessing this for color schemes and for specific figures in R.

## Desaturating palettes with colorspace
The *colorspace* package includes the function *desaturate()*, which can be used to test whether a palette will be distorted in black and white.

## Collapse color distinctions with dichromat
The **dichromat** package 

## Simulating color blindness with colorblindr
This package currently depends on the development versions of **cowplot** and **colorspace**, so let's install those first:
```{r}
remotes::install_github("wilkelab/cowplot")
install.packages("colorspace", repos = "http://R-Forge.R-project.org")
```

Then we can install **colorblindr** from repository:
```{r}
remotes::install_github("clauswilke/colorblindr")
```






# Facets: facet_wrap() and facet_grid()
Alternately, maybe we want to separate out different parts of the data onto separate plots. The function *facet_wrap()* lets us specify a single factor to use for separating the data. For example, if we want to plot Pokemon of different generations on different plots, we can do so:
```{r}
ggplot(pokemon, aes(attack, defense)) +  # data + aesthetics (x, y) 
  geom_point(aes(color=as.factor(generation_id))) +
  geom_smooth() +  # Produces a smoothed line showing data trends
  theme_classic()+
  facet_wrap(~generation_id)
```
Note that *facet_wrap()* automatically converted the numeric variable *generation_id* into a factor. 

In this call, *geom_smooth()* is applied to the data *within each grid panel*, but it hasn't inherited the color aesthetic. What happens if we move the color aesthetic into the "boss" call to *ggplot()*?
```{r}
ggplot(pokemon, aes(attack, defense, color=as.factor(generation_id))) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  geom_smooth() +  # Produces a smoothed line showing data trends
  theme_classic()+
  facet_wrap(~generation_id)
```

Now both geometries have inherited the same color aesthetic.

If we want to separate Pokemon by type:
```{r}
ggplot(pokemon, aes(attack, defense)) +  # data + aesthetics (x, y, point color) 
  geom_point(aes(color=as.factor(generation_id))) +
  geom_smooth() +  # Produces a smoothed line showing data trends
  theme_classic()+
  facet_wrap(~type_1)
```

Notice that the smoothing function is upset with us here - there aren't enough points in some of these panels for smoothing to work properly.

The function *facet_grid()* lets us separate the data by two factors simultaneously, making a grid. This function requires us to specify the data defining facet groups as *vars()*. Notice that we can specify which factor goes along rows vs. columns of the grid; if we don't specify, the first variable we provide will go down the rows and the second along the columns.
```{r}
ggplot(pokemon, aes(attack, defense)) +  # data + aesthetics (x, y, point color) 
  geom_point(aes(color=as.factor(generation_id))) +
  theme_light()+
  facet_grid(rows=vars(type_1), cols=vars(type_2))
```

This is a very big plot! Click on "Show in new window" to get a closer look.





# Other Geometries
This section is basically a code bank for your use.

## Histograms, Densities, and Violins
Histograms are handy for showing distributions:
```{r}
ggplot(pokemon, aes(hp)) +
  geom_histogram(color="white", # outline color
                 fill="darkgreen" # fill color
                 )+
  theme_classic()
```
As always, aesthetics can be informational:
```{r}
ggplot(pokemon, aes(hp, fill=type_1)) +
  geom_histogram(color="white", # outline color
                 binwidth=10)+
  theme_classic()+
  facet_wrap(~type_1)
```

Densities also show distributions nicely:
```{r}
ggplot(pokemon, aes(hp, fill=type_1)) +
  geom_density(color="grey")+
  theme_classic()+
  facet_wrap(~type_1)
```
To show distributions side by side, a violin plot can be attractive:
```{r}
ggplot(pokemon, aes(y=hp, x=type_1, fill=type_1)) +
  geom_violin()+
  theme_classic()+
  theme(axis.text.x = element_text(angle=45, vjust = 0.6))
```


If the number of points isn't too large, it is often recommended to over-plot the data:
```{r}
ggplot(pokemon, aes(y=hp, x=type_1, fill=type_1)) +
  geom_jitter(width=0.2, size=0.5)+
  geom_violin()+
  theme_classic()+
  theme(axis.text.x = element_text(angle=45, vjust = 0.6))
```
That didn't work. Geometries are deposited on the plot in order of appearance - if we want to see the data points AND have a color fill for the violins, we have to reverse the order:
```{r}
ggplot(pokemon, aes(y=hp, x=type_1, fill=type_1)) +
  geom_violin()+
  geom_jitter(width=0.2, size=0.5)+
  theme_classic()+
  theme(axis.text.x = element_text(angle=45, vjust = 0.6))
```

Or we can remove the violin fill. Now we need to switch to *color* instead of *fill* so that the data points have the right colors:
```{r}
ggplot(pokemon, aes(y=hp, x=type_1, color=type_1)) +
  geom_jitter(width=0.2, size=0.5)+
  geom_violin(fill=NA)+
  theme_classic()+
  theme(axis.text.x = element_text(angle=45, vjust = 0.6))
```


**EXERCISE:** Change the values on the plot options above to figure out what they do. (It can be helpful to copy a line of code, comment out the original, then start making changes to the copy - this lets you keep the old code for reference while you are breaking the options.)


## Bar Plots



## Labeling wih geom_text()
We can even use different data sets within a single plot. Similar to aesthetics, the data are inherited within a *ggplot()* call, *unless you specify otherwise*.


# Resources
https://thatdatatho.com/selectively-place-text-in-ggplots-geom_text/
https://thatdatatho.com/my-favourite-ggplot-plot-bar-chart-presentations/
https://thatdatatho.com/grammar-of-graphics-ggplot2/
https://thatdatatho.com/grammar-of-graphics-ggplot-tutorial-part2/
https://rpubs.com/theairbend3r/ggplot-em-all-pokemon
https://github.com/EmilHvitfeldt/r-color-palettes
https://github.com/clauswilke/colorblindr
