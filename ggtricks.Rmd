---
title: "gg_tricks"
output: html_notebook
---

# Getting started
This workshop assumes that you:
* Have R and Rstudio installed (this code was written in 4.3.1 "Beagle Scouts")
* Have a working directory set up for R
* Understand the basics of how R creates and handles objects
* Know the basic parts of a call to *ggplot()*, including how to change aesthetics and geometries


Before we begin, we'll need to install and load the packages we'll be working with from CRAN:
```{r}
pacman::p_load(tidyverse, pokemon, cowplot, ggpubr, gridExtra, ggsci)
```

If you attended the prior workshops, you've already been introduced to Tidyverse and the pokemon data set. We'll also be working with some packages that add new functionality to the ggverse:
* *cowplot* is an add-on to *ggplot* with features that help with creating publication-quality figures, including new themes and functions for assembly of compound multi-panel figures. 
* *gridExtra* allows for more complex plot gridding
* *ggpubr* allows users to annotate plots, including overlay of statistical comparisons directly onto plots, and provides some user-friendly tools for manipulating ggplot formatting
* *ggsci* has a variety of *ggplot2* color palettes inspired by scientific journals, data visualization libraries, movies, and TV shows

## Working with cowplot: themes and plot_grid
This package includes some new theme options to explore:
```{r}
ggplot(pokemon, aes(attack, defense, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  theme_minimal_vgrid()
#  theme_minimal_hgrid()
#  theme_minimal_grid(12)
#  theme_cowplot(12) # classic cowplot theme
```

Most of the functionality here is for creation of multipanel plots.
```{r}
# Save each ggplot as an object
p1 <- ggplot(pokemon, aes(attack, defense, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  theme_classic()
p2 <- ggplot(pokemon, aes(height, weight, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  theme_classic()

plot_grid(p1, p2,
#          labels="AUTO",  # labels panels as "A", "B" etc
          labels="auto",   # labels panels as "a", "b" etc
          label_size = 12)
```


The grid components can be basically any plot object. 
```{r}
p3 <-ggplot(pokemon, aes(attack, defense, color=as.factor(generation_id))) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  geom_smooth() +  # Produces a smoothed line showing data trends
  theme_classic()+
  facet_wrap(~generation_id) +
  labs(color="Generation")

plot_grid(p1, p3)
```


It may be wise to re-orient and/or re-size sub-plots:
```{r}
plot_grid(p1, p3, 
          nrow=1, # orient plots in a single row
          rel_widths = c(1.5,2), # change relative heights,
#          ncol=1, # orient plots in a single column
#          rel_heights = c(1,2), # change relative heights,
          labels = "AUTO"
          )
```


It is a little difficult to see what's happening in plot A. Let's rework it
```{r}
p1
p4 <- ggplot(pokemon, aes(attack, defense, color=type_1)) +  # data + aesthetics (x, y, point color)
  geom_point() +
  theme_classic() + 
  facet_wrap(~type_1)
p4
```

What else should we add or change to this plot?
How about modifying the labels / sizing?

How would you change the attack vs. defense plot for the different generations
(depending on what question you were asking)

**EXERCISE: You try it!** Create a new ggplot object and grid together two or more plots.
```{r}

```



*******************************************************************************************************************************************
# Intro to data manipulation in Tidyverse
Before we go any farther, we need to know how to manipulate data within tibbles. Tidyverse makes it very easy to do this. 

(**For each of the following:** How big do you expect the resulting tibble to be? How many rows and columns? Is that what you get? This is debugging 101 - if you know the properties of the object you are trying to produce, you can use that knowledge to figure out when something you've written is not working as intended.)

First, we can mutate (transform) existing columns and append the results to the tibble. First, let's see what the function does and how to call it:
```{r}
?mutate
```


Then we can use it:
```{r}
mydata<-mydata %>%
  mutate(lbs=2.2046*kg)
mydata
```

Sometimes after plotting, may realize that you want to manipulate the data some more to make different plots.
Let's say you want to look for a correlation between typing systems within a pokemon.
However, as an experienced pokeologist, you know that not all pokemon are dual typed.

```{r}
glimpse(pokemon) # taking a look at the data
sum(is.na(pokemon$type_2))
```

To deal with this, you may will need to remove non-dual-typed pokÃ©mon.
While we're at it, let's exclude some columns we don't care about.
```{r}
pokemon %>% select(-url_icon, -url_image) %>%
  na.exclude(type_2)
```

```{r}
pokemon %>% select(-url_icon, -url_image) %>%
  na.exclude(type_2) %>% ggplot(aes(x = type_1, y = type_2, fill = frequency())) + geom_tile()
  
```

*******************************************************************************************************************************************
Wait - what did we do there? That's called a **pipe**, and it comes from a Tidyverse package called **magrittr**. 

The pipe operator *%>%* "pipes" whatever is on the left-hand side of the "funnel" into the command(s) on the right-hand side. The object from the left-hand side of the pipe therefore becomes the data for the command(s) on the right-hand side.

The pipe is a great way to keep your R code clean, readable, and therefore maintanable. Consider the following example. Can you tell what this nest of function calls is doing?
```{r}
round(cos(exp(sin(log10(sqrt(25))))), 2)
```

It's a mess. If instead the functions are called through a series of pipes, it's much easier to see what's happening:
```{r}
sqrt(25) %>%   # Take the square root of 25...
  log10() %>%  # Find its base-10 log...
  sin() %>%    # Find the sine of the result...
  exp() %>%    # Calculate e^(that result)...
  cos() %>%    # Find the cosine of THAT result...
  round(2)     # And round it to two decimal places.
```

What the pipe is doing is putting the result from the left-hand side (or in our case from above) and put it into the right hand side (or in our case into the code below). When we write out code this way, it's much easier to see what is happening, as well as to fix any mistakes.
*******************************************************************************************************************************************

But let's get back to parsing our data. We can select only specific columns:
```{r}
mydata %>%
  select(animal, body_len)
```

or a range of columns:
```{r}
mydata %>%
  select(animal:body_len)
```

We can filter a tibble, retaining only the rows that satisfy a given condition:
```{r}
mydata %>%
  filter(kg>25)
```

There's more functionality available here (lots more!) but these are some of the most useful basic operations to have when handling tibbles.




## Publication-quality plots with ggpubr



# The Wider ggverse: devtools


# ggsci
ggsci has a variety of color pallates that can be used for giving your plots the color scheme of many scientific journals, TV shows, and movies.

These colors can be fun, but they are not necessarily color-blind friendly or good for printing, so they are not the best choice for all applications.




# Resources
https://github.com/schochastics/Rokemon
https://cran.r-project.org/web/packages/pokemon/index.html
https://thatdatatho.com/r-resources-beginner-advanced/
https://thatdatatho.com/7-tidyverse-tricks-for-getting-your-data-into-the-right-shape/
https://thatdatatho.com/grammar-of-graphics-ggplot2/
https://thatdatatho.com/grammar-of-graphics-ggplot-tutorial-part2/
https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html

