---
title: "gg_tricks"
output: html_notebook
---

# Getting started
This workshop assumes that you:
* Have R and Rstudio installed (this code was written in 4.3.1 "Beagle Scouts")
* Have a working directory set up for R
* Understand the basics of how R creates and handles objects
* Know the basic parts of a call to *ggplot()*, including how to change aesthetics and geometries


Before we begin, we'll need to install and load the packages we'll be working with from CRAN:
```{r}
pacman::p_load(tidyverse, pokemon, cowplot, ggpubr, gridExtra, ggsci, devtools)
```

If you attended the prior workshops, you've already been introduced to Tidyverse and the pokemon data set. We'll also be working with some packages that add new functionality to the ggverse:
* *cowplot* is an add-on to *ggplot* with features that help with creating publication-quality figures, including new themes and functions for assembly of compound multi-panel figures. 
* *gridExtra* allows for more complex plot gridding
* *ggpubr* allows users to annotate plots, including overlay of statistical comparisons directly onto plots, and provides some user-friendly tools for manipulating ggplot formatting
* *ggsci* has a variety of *ggplot2* color palettes inspired by scientific journals, data visualization libraries, movies, and TV shows

# Working with cowplot: themes and plot_grid
This package includes some new theme options to explore:
```{r}
ggplot(pokemon, aes(attack, defense, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point() +
#  theme_minimal_vgrid()
#  theme_minimal_hgrid()
#  theme_minimal_grid(12)
  theme_cowplot(12) # classic cowplot theme
```

Most of the functionality here is for creation of multipanel plots.
```{r}
# Save each ggplot as an object
p1 <- ggplot(pokemon, aes(attack, defense, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  theme_classic()
p2 <- ggplot(pokemon, aes(height, weight, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  theme_classic()

plot_grid(p1, p2,
#          labels="AUTO",  # labels panels as "A", "B" etc
          labels="auto",   # labels panels as "a", "b" etc
          label_size = 12)
```


The grid components can be basically any plot object. 
```{r}
p3 <- ggplot(pokemon, aes(attack, defense, color=as.factor(generation_id))) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  geom_smooth() +  # Produces a smoothed line showing data trends
  theme_classic()+
  facet_wrap(~generation_id) +
  labs(color="Generation")

plot_grid(p1, p3)
```


It may be wise to re-orient and/or re-size sub-plots:
```{r}
plot_grid(p1, p3, 
          nrow=1, # orient plots in a single row
          rel_widths = c(1.5,2), # change relative heights,
#          ncol=1, # orient plots in a single column
#          rel_heights = c(1,2), # change relative heights,
          labels = "AUTO"
          )
```


It is a little difficult to see what's happening in plot A. Let's rework it
```{r}
p1
p4 <- ggplot(pokemon, aes(attack, defense, color=type_1)) +  # data + aesthetics (x, y, point color)
  geom_point() +
  theme_classic() + 
  facet_wrap(~type_1)
p4
```

What else should we add or change to this plot?
How about modifying the labels / sizing?

How would you change the attack vs. defense plot for the different generations
(depending on what question you were asking)

**EXERCISE: You try it!** Create a new ggplot object and grid together two or more plots.
```{r}

```


*******************************************************************************************************************************************
# Intro to data manipulation in Tidyverse
Before we go any farther, we need to know how to manipulate data within tibbles. Tidyverse makes it very easy to do this. 

(**For each of the following:** How big do you expect the resulting tibble to be? How many rows and columns? Is that what you get? This is debugging 101 - if you know the properties of the object you are trying to produce, you can use that knowledge to figure out when something you've written is not working as intended.)

First, we can mutate (transform) existing columns and append the results to the tibble. First, let's see what the function does and how to call it:
```{r}
?mutate
```

Then we can use it:
```{r}
pokemon <- pokemon %>%
  mutate(lbs=2.2046*weight)
pokemon
```
*******************************************************************************************************************************************
Wait - what did we do there? That's called a **pipe**, and it comes from a Tidyverse package called **magrittr**. 

The pipe operator *%>%* "pipes" whatever is on the left-hand side of the "funnel" into the command(s) on the right-hand side. The object from the left-hand side of the pipe therefore becomes the data for the command(s) on the right-hand side.

The pipe is a great way to keep your R code clean, readable, and therefore maintanable. Consider the following example. Can you tell what this nest of function calls is doing?
```{r}
round(cos(exp(sin(log10(sqrt(25))))), 2)
```

It's a mess. If instead the functions are called through a series of pipes, it's much easier to see what's happening:
```{r}
sqrt(25) %>%   # Take the square root of 25...
  log10() %>%  # Find its base-10 log...
  sin() %>%    # Find the sine of the result...
  exp() %>%    # Calculate e^(that result)...
  cos() %>%    # Find the cosine of THAT result...
  round(2)     # And round it to two decimal places.
```

What the pipe is doing is putting the result from the left-hand side (or in our case from above) and put it into the right hand side (or in our case into the code below). When we write out code this way, it's much easier to see what is happening, as well as to fix any mistakes.

*******************************************************************************************************************************************

# select() and filter(): basic data manipulation

But let's get back to parsing our data. We can select only specific columns:
```{r}
pokemon %>%
  select(pokemon, height)
```

or a range of columns:
```{r}
pokemon %>%
  select(pokemon:height)
```

We can filter a tibble, retaining only the rows that satisfy a given condition:
```{r}
pokemon %>%
  filter(weight > 25)
```

There's more functionality available here (lots more!) but these are some of the most useful basic operations to have when handling tibbles.

*******************************************************************************************************************************************

# More data manipulation tricks

Sometimes after plotting, may realize that you want to manipulate the data some more to make different plots.
I'm curious about the mega evolutions, but we need to do some exploration before we can plot.

Which pokemon have mega evolutions? Let's use grep and stringr to extract the rows that we're interested in
```{r}
#hits <- grep("mega", pokemon$pokemon, fixed = TRUE, value = TRUE)
#hits
#what is the problem with this? why do I need to do this differently?

hits <- as.data.frame(grep("-mega", pokemon$pokemon, fixed = TRUE, value = TRUE)) %>%
  rename("mega" = 'grep("-mega", pokemon$pokemon, fixed = TRUE, value = TRUE)')

hits$reg <- hits$mega %>%
  str_replace("-mega.*$", "")

```

The data isn't in the right format. We need to pivot it before we continue
```{r}
hitlong <- pivot_longer(hits, cols = everything())
```

Now that we have a df with the names of mega and their regular counterpart, let's join with the original pokemon dataframe to get the stats for these pokemon
```{r}
left_join(hitlong, pokemon, by = c("value" = "pokemon"))

#let's keep this for future use...
lj <- left_join(hitlong, pokemon, by = c("value" = "pokemon")) %>%
  select(-url_icon, -url_image) %>%
  distinct() # only print identical lines once
  
glimpse(lj)
```

What happens if we use the other types of join? Why do we know this is the correct one?
(hint: check the number of rows in the df)


# Publication-quality plots with ggpubr
ggpubr can be used to make plots more quickly and easily.

Let's use ggpubr to make some plots comparing mega and regular pokemon
```{r}
aplot <- ggdensity(lj, x = "attack",
                   add = "mean", rug = TRUE,
                   color = "name", fill = "name",
                   palette = c("#00AFBB", "#E7B800"))

dplot <- ggdensity(lj, x = "defense",
                   add = "mean", rug = TRUE,
                   color = "name", fill = "name",
                   palette = c("#00AFBB", "#E7B800"))

plot_grid(aplot, dplot)
```

What else should we do to make this plot prettier before we send it off?

To ask this question a different way, I should use all regulars and a different join.
Do the pokemon that have a mega evolution have a lower regular attack/defense?


# The Wider ggverse: devtools
devtools has a variety of tools that facilitate package devlopment. In this case, we can install packages that are *not* on CRAN. This expands the tools available to us!

Let's use it to get some more color-blind friendly palettes from 
```{r}
devtools::install_github("JLSteenwyk/ggpubfigs")
library(ggpubfigs)
```

# ggsci
ggsci has a variety of color pallates that can be used for giving your plots the color scheme of many scientific journals, TV shows, and movies.

These colors can be fun, but they are not necessarily color-blind friendly or good for printing, so they are not the best choice for all applications.


# Resources
https://github.com/schochastics/Rokemon
https://cran.r-project.org/web/packages/pokemon/index.html
https://thatdatatho.com/r-resources-beginner-advanced/
https://thatdatatho.com/7-tidyverse-tricks-for-getting-your-data-into-the-right-shape/
https://thatdatatho.com/grammar-of-graphics-ggplot2/
https://thatdatatho.com/grammar-of-graphics-ggplot-tutorial-part2/
https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html
https://devtools.r-lib.org/index.html

