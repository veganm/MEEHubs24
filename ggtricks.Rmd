---
title: "gg_tricks"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.



# Getting started
This workshop assumes that you:
* Have R and Rstudio installed (this code was written in 4.3.1 "Beagle Scouts")
* Have a working directory set up for R
* Understand the basics of how R creates and handles objects
* Know the basic parts of a call to *ggplot()*, including how to change aesthetics and geometries


Before we begin, we'll need to install and load the packages we'll be working with from CRAN:
```{r}
pacman::p_load(tidyverse, pokemon, cowplot, ggpubr, gridExtra)
```

If you attended the prior workshops, you've already been introduced to Tidyverse and the pokemon data set. We'll also be working with some packages that add new functionality to the ggverse:
* *cowplot* is an add-on to *ggplot* with features that help with creating publication-quality figures, including new themes and functions for assembly of compound multi-panel figures. 
* *gridExtra* allows for more complex plot gridding
* *ggpubr* allows users to annotate plots, including overlay of statistical comparisons directly onto plots, and provides some user-friendly tools for manipulating ggplot formatting

## Working with cowplot: themes and plot_grid
This package includes some new theme options to explore:
```{r}
ggplot(pokemon, aes(attack, defense, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  theme_minimal_vgrid()
#  theme_minimal_hgrid()
#  theme_minimal_grid(12)
#  theme_cowplot(12) # classic cowplot theme
```

Most of the functionality here is for creation of multipanel plots.
```{r}
# Save each ggplot as an object
p1<- ggplot(pokemon, aes(attack, defense, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  theme_classic()
p2<- ggplot(pokemon, aes(height, weight, color=type_1)) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  theme_classic()

plot_grid(p1, p2,
#          labels="AUTO",  # labels panels as "A", "B" etc
          labels="auto",   # labels panels as "a", "b" etc
          label_size = 12)
```


The grid components can be basically any plot object. 
```{r}
p3<-ggplot(pokemon, aes(attack, defense, color=as.factor(generation_id))) +  # data + aesthetics (x, y, point color) 
  geom_point() +
  geom_smooth() +  # Produces a smoothed line showing data trends
  theme_classic()+
  facet_wrap(~generation_id) +
  labs(color="Generation")

plot_grid(p1, p3)
```


It may be wise to re-orient and/or re-size sub-plots:
```{r}
plot_grid(p1, p3, 
          nrow=1, # orient plots in a single row
          rel_widths = c(1.5,2), # change relative heights,
#          ncol=1, # orient plots in a single column
#          rel_heights = c(1,2), # change relative heights,
          labels = "AUTO"
          )
```


**EXERCISE: You try it!** Create a new ggplot object and grid together two or more plots.
```{r}

```



*******************************************************************************************************************************************
# Intro to data manipulation in Tidyverse
Before we go any farther, we need to know how to manipulate data within tibbles. Tidyverse makes it very easy to do this. 

(**For each of the following:** How big do you expect the resulting tibble to be? How many rows and columns? Is that what you get? This is debugging 101 - if you know the properties of the object you are trying to produce, you can use that knowledge to figure out when something you've written is not working as intended.)

First, we can mutate (transform) existing columns and append the results to the tibble. First, let's see what the function does and how to call it:
```{r}
?mutate
```


Then we can use it:
```{r}
mydata<-mydata %>%
  mutate(lbs=2.2046*kg)
mydata
```


*******************************************************************************************************************************************
Wait - what did we do there? That's called a **pipe**, and it comes from a Tidyverse package called **magrittr**. 

The pipe operator *%>%* "pipes" whatever is on the left-hand side of the "funnel" into the command(s) on the right-hand side. The object from the left-hand side of the pipe therefore becomes the data for the command(s) on the right-hand side.

The pipe is a great way to keep your R code clean, readable, and therefore maintanable. Consider the following example. Can you tell what this nest of function calls is doing?
```{r}
round(cos(exp(sin(log10(sqrt(25))))), 2)
```

It's a mess. If instead the functions are called through a series of pipes, it's much easier to see what's happening:
```{r}
sqrt(25) %>%   # Take the square root of 25...
  log10() %>%  # Find its base-10 log...
  sin() %>%    # Find the sine of the result...
  exp() %>%    # Calculate e^(that result)...
  cos() %>%    # Find the cosine of THAT result...
  round(2)     # And round it to two decimal places.
```

What the pipe is doing is putting the result from the left-hand side (or in our case from above) and put it into the right hand side (or in our case into the code below). When we write out code this way, it's much easier to see what is happening, as well as to fix any mistakes.
*******************************************************************************************************************************************

But let's get back to parsing our data. We can select only specific columns:
```{r}
mydata %>%
  select(animal, body_len)
```

or a range of columns:
```{r}
mydata %>%
  select(animal:body_len)
```

We can filter a tibble, retaining only the rows that satisfy a given condition:
```{r}
mydata %>%
  filter(kg>25)
```

There's more functionality available here (lots more!) but these are some of the most useful basic operations to have when handling tibbles.




## Publication-quality plots with ggpubr



# The Wider ggverse: devtools





# Resources
https://github.com/schochastics/Rokemon
https://cran.r-project.org/web/packages/pokemon/index.html
https://thatdatatho.com/r-resources-beginner-advanced/
https://thatdatatho.com/7-tidyverse-tricks-for-getting-your-data-into-the-right-shape/
https://thatdatatho.com/grammar-of-graphics-ggplot2/
https://thatdatatho.com/grammar-of-graphics-ggplot-tutorial-part2/
https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html

